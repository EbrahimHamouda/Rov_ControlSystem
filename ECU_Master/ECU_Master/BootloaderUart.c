/*
*
*
* Created: 2/13/2019 3:10:05 AM
*  Author: Ebrahim Hamouda

*/

#include <string.h>
#include <common/ebra_common.h>
#include <avr/io.h>
#include <avr/boot.h>
#include <avr/interrupt.h>
#include "F:\embedded\Work_space\2_Drivers_atmega32\SDK_AVR_ATMEGA32\HAL\UART\USART.h"
#include "F:\embedded\Work_space\2_Drivers_atmega32\SDK_AVR_ATMEGA32\SERVICE\comm_RX\commRX.h"

#define PAGESIZE      128
#define APP_SIZE      146
#define START_ADD     0x00

// this arry should be deliverd by uart channel >> i can't simulate this in Atmel stud
unsigned char App_program[]={0x0C,0x94,0x2A,0x00,0x0C,0x94,0x34,0x00,0x0C,0x94,0x34,0x00,0x0C,0x94,0x34,0x00,0x0C,0x94,0x34,0x00,0x0C,0x94,0x34,0x00,0x0C,0x94,0x34,0x00,0x0C,0x94,0x34,0x00,0x0C,0x94,0x34,0x00,0x0C,0x94,0x34,0x00,0x0C,0x94,0x34,0x00,0x0C,0x94,0x34,0x00,0x0C,0x94,0x34,0x00,0x0C,0x94,0x34,0x00,0x0C,0x94,0x34,0x00,0x0C,0x94,0x34,0x00,0x0C,0x94,0x34,0x00,0x0C,0x94,0x34,0x00,0x0C,0x94,0x34,0x00,0x0C,0x94,0x34,0x00,0x0C,0x94,0x34,0x00,0x11,0x24,0x1F,0xBE,0xCF,0xE5,0xD8,0xE0,0xDE,0xBF,0xCD,0xBF,0x0E,0x94,0x36,0x00,0x0C,0x94,0x3E,0x00,0x0C,0x94,0x00,0x00,0x8F,0xEF,0x8A,0xBB,0x1B,0xBA,0x91,0xE0,0x8B,0xB3,0x89,0x27,0x8B,0xBB,0xFC,0xCF,0xF8,0x94,0xFF,0xCF};
void boot_program_page (uint32_t page, uint8_t *buf);

uint8_t integ  ; //0>>255 page numbers
uint8_t remain ; //0>>128 remain bytes 
uint8_t buf[PAGESIZE]; // buffer to be transmited to flash

int main(void)
{
	uint16 i;
	remain=APP_SIZE-(PAGESIZE*integ);
	if(integ)
	{
		for(i = 0 ; i< integ ; i++ )
		{
			memcpy(buf,(App_program+(i*128)),PAGESIZE);
			boot_program_page(START_ADD + (i*128) ,buf);
		}
	}
	if(remain)
	{
		memset(buf , 0xFF , SPM_PAGESIZE) ; // As the remaining bytes are less than PAGE_SIZE
		memcpy(buf,(App_program+(integ*128)),remain);
		boot_program_page(START_ADD + (integ*128) , buf) ;
	}
	
	boot_rww_enable ();
	((void (*)(void)) START_ADD)() ;  // call the first addrass 
}

